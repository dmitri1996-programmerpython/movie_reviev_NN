# -*- coding: utf-8 -*-
"""movie_reviev_NN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vhWA6ATaRORpwg5lVNUMOhWf_s3vyPBn

#Приложение которое пишет рецензию на фильм основываясь на его названии

#Ходырев Дмитрий Валерьевич

Библиотеки для парсинга

#Многие люди не могут определится с выбором фильма, этот код позволит создать приложение которое будет рекомендовать смотреть или наоборот отговаривать смотреть этот фильм основываясь на данных полученных из интернета.
"""

import requests
from bs4 import BeautifulSoup as bs
import random
from time import sleep

"""Библиотеки для создания DataFrame и анализа данных"""

import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import sqlite3

"""Спарсим ссылки на фильмы с сервиса "https://www.film.ru", запишем все ссылки в отдельный файл "link_films.txt"
"""

link = []
for films in range(500):
  headers = {
      'user-agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Mobile Safari/537.36'}
  url = f'https://www.film.ru/a-z/movies/html?page={films}&js=true'
  r = requests.get(url, headers)
  q = r.text
  soup = bs(q, features="html.parser")
  film = soup.find_all('div', class_='film_list')
  for i in film:
    i = i.find('a').get('href')
    link.append(i)
  sleep(random.randint(2, 4))

link_pol = []
for f in link:
  f = 'https://www.film.ru' + f
  link_pol.append(f)

with open("link_films.txt", "a") as file:
    for line in link_pol:
      file.write(f'{line}\n')

"""Откроем файл, и начнем собирать информацию по каждому фильму, для этого создадим цикл который будет проходится по каждой ссылке и забирать оттуда название фильма, год выпуска, режиссера, сценаристов, длительность, сборы в США и сборы в мире, а так же зрительскую оценку фильма"""

#создадим список для записи данных по каждому фильму
data_sp = []

with open('/content/link_films.txt') as file:
  lines = [line.strip() for line in file.readlines()]
  for line in lines:
    q = requests.get(line)
    result = q.content
    soup = bs(result)
    film_name = soup.find('div', class_='movies-center').find('h1').text
    table1 = soup.find('div', class_='movies-center-table')
    table2 = table1.findAll('strong')
    table3 = []
    for t in table2:
      t = t.text.split()
      table3.append(t)
    for clas in range(1,10):
      try:
        grade = soup.find('div', class_=f'square br{clas}').find('strong').text.strip()
      except AttributeError:
        continue
            
    
    data = {
        'Название фильма': film_name,
        'Таблица данных': table3,
        'Зрительская оценка': grade[:3]
    }
    data_sp.append(data)

"""Запишем все наши данные в текстовый файл data.txt"""

with open("data.txt", "a") as file:
    for line in data_sp:
      file.write(f'{line}\n')

"""Создадим таблицу для записи в нее наших данных"""

data_films = pd.DataFrame([], columns = ['Название фильма/год выпуска','Продолжительность', 'Режиссер', 'Сценарий', 'Бюджет', 'Сборы(США)', 'Премьера', 'Зрительская оценка'])
data_films

"""Загузим данные из файла data.txt и подготовим их для записи в таблицу"""

lines = open('/content/data.txt', 'r')

"""Разделим всю информацию на списки, которые соответствуют стобцам нашей таблицы

---


"""

name_str = [] #список с названиями фильмов
duration = [] #список с продолжительстью фильмов
director = [] #список с режисерами фильмов
scenario = [] #список со сценаристами
fees = [] #список со сборами
budget = [] #список с бюджетами
premier = [] #список с датами премьер
grade_str = [] #список со зрительскими оценками
for lienst in lines: #цикл, который проходится по каждой строке
  try:                                #Применим контрукцию try except для исключения ошибки индексов и запишем все наши дразделенные данные в списки которые создали
    lienst = lienst.split(":", 3) #делим нашу строку на список по двоеточию
    table_data = lienst[2].split(']', 6)   #так как во втором элементе нашего списка получился список с данными из таблицы которую мы спарсили, делим второй элемент на еще один список по закрывающей квадратной скобке

                                 
    name_str.append(lienst[1]) 
    duration.append(table_data[0])
    director.append(table_data[1])
    scenario.append(table_data[2])
    fees.append(table_data[4])
    premier.append(table_data[5])
    budget.append(table_data[3])
    grade_str.append(lienst[3])
  except IndexError:
    continue

"""Для того чтобы данные в таблице выглядели опрятно пройдемся по нашим спискам методом replace и почистим от ненужных символов"""

#создадим новые списки с приставкой _clean
name_str_clean = [] #список с названиями фильмов
duration_clean = [] #список с продолжительстью фильмов
director_clean = [] #список с режисерами фильмов
scenario_clean = [] #список со сценаристами
fees_clean = [] #список со сборами
budget_clean = [] #список с бюджетами
premier_clean = [] #список с датами премьер
grade_str_clean = [] #список со зрительскими оценками

for clean_name in name_str:       #Почистим колонку с названиями фильмов
  clean_name = clean_name.replace("'", '').replace(", Таблица данных",'')
  name_str_clean.append(clean_name)

for clean_duration in duration:   #колонка с длительностью фильмов
  clean_duration = clean_duration.replace('[', '').replace("'",'').replace(',', '')
  duration_clean.append(clean_duration)

for clean_director in director:   #колонка с режиссерами
  clean_director = clean_director.replace("'",'').replace('[', '').replace(',','')
  director_clean.append(clean_director)

for clean_scenario in scenario:  #колонка со сценаристами
  clean_scenario = clean_scenario.replace("'",'').replace('[', '').replace(',','')
  scenario_clean.append(clean_scenario)

for clean_fees in fees:          #колонка со сборами
  clean_fees = clean_fees.replace("'",'').replace('[', '').replace(',','')
  fees_clean.append(clean_fees)

for clean_budget in budget:      #колонка с бюджетом фильма
  clean_budget = clean_budget.replace("'",'').replace('[', '').replace(',','').replace(' $', '')
  try:
    clean_budget = float(clean_budget)
  except:
    budget_clean.append(clean_budget)
  budget_clean.append(clean_budget)

for clean_premier in premier:    #колонка с датой премьеры
  clean_premier = clean_premier.replace("'",'').replace('[', '').replace(',','')
  premier_clean.append(clean_premier)

for clean_grade_str in grade_str:  #колонка со зрительской оценкой
  clean_grade_str = clean_grade_str.replace("'",'').replace('[', '').replace(',','').replace('\n', '').replace('}','').replace(' ', '')
  clean_grade_str = float(clean_grade_str)
  grade_str_clean.append(clean_grade_str)

c = 0                    #Создадим цикл for i in range('Количество строк в таблице') это мы зунали из количества элементов в любом созданном нами списке
for i in range(21800):   #Запишем в таблицу все наши данные
  try:  
    data_films.loc[c, 'Название фильма/год выпуска'] = name_str_clean[i]
    data_films.loc[c, 'Продолжительность'] = duration_clean[i]
    data_films.loc[c, 'Режиссер'] = director_clean[i]
    data_films.loc[c, 'Сценарий'] = scenario_clean[i]
    data_films.loc[c, 'Бюджет'] = budget_clean[i]
    data_films.loc[c, 'Сборы(США)'] = fees_clean[i]
    data_films.loc[c, 'Премьера'] = premier_clean[i]
    data_films.loc[c, 'Зрительская оценка'] = grade_str_clean[i]
  except IndexError:
    continue
  c += 1

data_films

"""#В собранном датасете получилось 12031 строка и столбцы Название фильма/год выпуска,	Продолжительность,	Режиссер,Сценарий, Бюджет,	Сборы(США),	Премьера,	Зрительская оценка. Из этих данных нам понадобятся только данные с числовимы значениями

проанализируем таблицу
"""

data_films['Сборы(США)']

"""Видим что в столбике со сборами очень много аномалий, давайте уберем все лишнее и оставим только список из одного числа для последующего использования"""

fees_clean_number = []   #Очистим наш список от лишних сисволов и запишем в новый
for f in fees_clean:
  f = f.replace('(США)', '').replace('(РФ)','').replace('$','').replace(' руб.', '').replace(' ', '')
  f = f.split('(мир)', 1)

  fees_clean_number.append(f[:1])

fees_number = [] #так же очистим от оставшихся лишних символов и переведем данные в списке в числовые значения
for f in fees_clean_number:
  f = str(f).replace('[', '').replace(']', '').replace("'", '')
  try:
    f = int(f)
  except:
    continue
  fees_number.append(f)

"""В столбике со зрительской оценкой у нас все в порядке"""

data_films['Зрительская оценка'].plot()

"""Проанализировав таблицу мы видим что в колонку с бюджетами фильмом попадают данные с других слобов, давайте подготовим список и оставим там только значения с числами"""

budget_clean_float = []
for b in budget_clean:
  try:
    b = int(b)
  except:
    continue
  budget_clean_float.append(b)

"""Осталось 2053 значений в списке budget_clean_float

Давайте создадим новую таблицу, куда запишем числовые значения на основе которых будем обучать модель
"""

df_education = pd.DataFrame([], columns=['Зрительская оценка', 'Бюджет', 'Сборы', 'Рецензия'])

f=0
for i in range(2053):
  df_education.loc[f, 'Зрительская оценка'] = data_films['Зрительская оценка'][i]
  df_education.loc[f, 'Бюджет'] = budget_clean_float[i]
  df_education.loc[f, 'Сборы'] = fees_number[i]
  f += 1

df_education

"""На основе сборов и бюджета создадим новый столбец для записив в него бинарного разделения "1 - это сборы превышают бюджет", "0 - это бюджет превышает сборы"
"""

df_education['Рецензия'] = np.where(df_education['Сборы']>df_education['Бюджет'], 1, 0)
df_education

"""Так же создадим стобец с рецензией по оценке зрителей если оценка выше 7 то поставим "1", если ниже то "0"
"""

df_education['Рецензия зрителей'] = np.where(df_education['Зрительская оценка']>=7, 1, 0)
df_education

"""Исходя из зрительского опыта фильм редко бывает хорошоим только из-за того что сборы превысили бюджет, но оценка почти всегда наглядно показывается о качестве фильм, поэтому мы оставим в качестве рецензии только столбец основанный на зрительской оценке"""

df_education = df_education.drop(columns='Рецензия') 
df_education

"""Мы получили таблицу с числовыми значениями на основе которой можно обучить модель определять качество фильма"""

from sklearn.tree import DecisionTreeClassifier #классификатор
from sklearn.model_selection import train_test_split #для разделения данных
from sklearn import metrics #для вычисления точности

X = df_education.loc[:, 'Зрительская оценка': 'Сборы'] #На чем обучаемся
y = df_education['Рецензия зрителей'] #Целевой столбец

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state=1)

clf = DecisionTreeClassifier(criterion='entropy', max_depth=1)
clf = clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

"""Модель обучения пишет что обучена на 100%, такое бывает при использовании метода Дерево решений"""

print(format(clf.score(X_train, y_train)))
print(format(clf.score(X_test, y_test)))

"""Проверим нашу модель, создадим такую же таблицу но с другими рандомными данными"""

df_test = pd.DataFrame([], columns = ['Зрительская оценка', 'Бюджет', 'Сборы'])
df_test

import random
grade_test = []
for f in range(10):
  f = random.randint(1.0, 10.0)
  grade_test.append(f)

fees_test = []
for f in range(10):
  f = random.randint(1000000, 100000000)
  fees_test.append(f)

budget_test = []
for f in range(10):
  f = random.randint(1000000, 100000000)
  budget_test.append(f)

f=0
for i in range(10):
  df_test.loc[f, 'Зрительская оценка'] = grade_test[i]
  df_test.loc[f, 'Бюджет'] = budget_test[i]
  df_test.loc[f, 'Сборы'] = fees_test[i]
  f += 1

df_test

"""передаем наш дататфрейм в обученную модель"""

pred = clf.predict(df_test)
pred

"""Визуально сравниваем и видим что модель по полученному датафрейму правильно опеределила оценку фильма

Данный код, как и модель можно реализовать в телеграмм канале или допустим для вк бота, а так же в приложении. Необходимо по названию фильма делать get запрос на какой либо сервис с информацией о фильме и на основе полученных данных модель укажет на качество этого фильма, пользователь будет знать стоит ли смотреть фильм или все таки лучше найти другой. Так же можно усовершенствовать данную модель по классификации фильмов, не все фильмы с плохой оценкой или с маленькими сборами действительно плохи. Разбить имеющуюся классификацию на еще несколько подвидов и так далее.

Так же приложение(телеграмм канал/чат бот) будет иметь психологический характер, пользователь будет спрашивать у копьютера посмотреть ли ему этот фильм, а не принимать решение сам, ведь ингда так трудно определится... Идея придумана для упрощения потребности с которой я и сам нередко сталкиваюсь
"""